#!/usr/bin/env bun

/**
 * Item Icon Sync Script for LolTimeFlash Mobile
 *
 * Copies item icons from the LaneGap web project,
 * compresses them with Sharp, and generates the TypeScript index.
 *
 * Run: bun run scripts/sync-items.ts
 */

import { existsSync } from 'fs'
import { mkdir, readdir, readFile, rm, stat, writeFile } from 'fs/promises'
import { join } from 'path'

// Paths
const LANEGAP_ITEMS_DIR = join(__dirname, '../../../LaneGap/public/items')
const MOBILE_ITEMS_DIR = join(__dirname, '../assets/items')
const INDEX_FILE = join(MOBILE_ITEMS_DIR, 'index.ts')

// Try to import sharp (optional)
let sharp: typeof import('sharp') | null = null
try {
  sharp = require('sharp')
  console.log('âœ… Sharp available - will optimize images')
} catch {
  console.log('âš ï¸ Sharp not available - will copy images without optimization')
  console.log('   Install with: bun add -d sharp')
}

interface ItemMetadata {
  id: string
  name: string
  gold: number
}

async function main() {
  const args = process.argv.slice(2)
  const fresh = args.includes('--fresh')

  console.log('\nğŸ® Item Icon Sync Script for LolTimeFlash Mobile\n')

  // Check if source directory exists
  if (!existsSync(LANEGAP_ITEMS_DIR)) {
    console.error('âŒ LaneGap items directory not found:', LANEGAP_ITEMS_DIR)
    console.log('   Make sure LaneGap project is at the same level')
    process.exit(1)
  }

  // Clean if fresh
  if (fresh && existsSync(MOBILE_ITEMS_DIR)) {
    console.log('ğŸ—‘ï¸  Cleaning existing data...')
    await rm(MOBILE_ITEMS_DIR, { recursive: true })
  }

  // Ensure output directory exists
  if (!existsSync(MOBILE_ITEMS_DIR)) {
    await mkdir(MOBILE_ITEMS_DIR, { recursive: true })
  }

  // Read metadata from LaneGap
  const metadataPath = join(LANEGAP_ITEMS_DIR, 'metadata.json')
  let items: ItemMetadata[] = []

  if (existsSync(metadataPath)) {
    const metadataContent = await readFile(metadataPath, 'utf-8')
    const metadata = JSON.parse(metadataContent)
    items = metadata.items || []
    console.log(`ğŸ“– Loaded ${items.length} items from metadata.json\n`)
  }

  // Read all PNG files
  const files = await readdir(LANEGAP_ITEMS_DIR)
  const pngFiles = files.filter((f) => f.endsWith('.png'))

  console.log(`ğŸ“ Found ${pngFiles.length} item icons\n`)

  // Process images
  let processed = 0
  let totalOriginalSize = 0
  let totalOptimizedSize = 0
  const processedItems: { id: string; name: string }[] = []

  for (const file of pngFiles) {
    const srcPath = join(LANEGAP_ITEMS_DIR, file)
    const itemId = file.replace('.png', '')
    const destPath = join(MOBILE_ITEMS_DIR, `${itemId}.webp`)

    const originalStat = await stat(srcPath)
    totalOriginalSize += originalStat.size

    if (sharp) {
      // Optimize with sharp - convert to webp
      await sharp(srcPath)
        .webp({ quality: 85, effort: 6 })
        .resize(64, 64, { fit: 'cover' })
        .toFile(destPath)
    } else {
      // Just copy as-is (PNG)
      const { copyFile } = await import('fs/promises')
      await copyFile(srcPath, join(MOBILE_ITEMS_DIR, file))
    }

    const destStat = await stat(sharp ? destPath : join(MOBILE_ITEMS_DIR, file))
    totalOptimizedSize += destStat.size

    // Find item name from metadata
    const itemMeta = items.find((i) => i.id === itemId)
    processedItems.push({
      id: itemId,
      name: itemMeta?.name || `Item ${itemId}`,
    })

    processed++
    if (processed % 50 === 0 || processed === pngFiles.length) {
      process.stdout.write(`\râ³ Processing: ${processed}/${pngFiles.length}`)
    }
  }

  console.log('\n')

  // Size report
  const originalKB = (totalOriginalSize / 1024).toFixed(1)
  const optimizedKB = (totalOptimizedSize / 1024).toFixed(1)
  const savedPercent = (
    (1 - totalOptimizedSize / totalOriginalSize) *
    100
  ).toFixed(1)

  console.log(
    `ğŸ“Š Size: ${originalKB}KB â†’ ${optimizedKB}KB (${savedPercent}% saved)\n`
  )

  // Sort items by ID
  processedItems.sort((a, b) =>
    a.id.localeCompare(b.id, undefined, { numeric: true })
  )

  // Generate TypeScript index
  console.log('ğŸ“ Generating TypeScript index...\n')

  const extension = sharp ? 'webp' : 'png'

  let indexContent = `/**
 * Static item icon mappings
 * Auto-generated by scripts/sync-items.ts
 *
 * Total: ${processedItems.length} items
 */
import { ImageSourcePropType } from 'react-native'

export interface IItem {
  id: string
  name: string
  source: ImageSourcePropType
}

// Item mappings - using require for static bundling
const ITEM_SOURCES: Record<string, ImageSourcePropType> = {
`

  for (const item of processedItems) {
    indexContent += `  '${item.id}': require('./${item.id}.${extension}'),\n`
  }

  indexContent += `}

// All items array
export const ITEMS: IItem[] = [
`

  for (const item of processedItems) {
    const escapedName = item.name.replace(/'/g, "\\'")
    indexContent += `  { id: '${item.id}', name: '${escapedName}', source: ITEM_SOURCES['${item.id}'] },\n`
  }

  indexContent += `]

/**
 * Get item icon source by ID
 * @param itemId - The item ID (e.g., '3089' for Rabadon's)
 * @returns ImageSourcePropType for the item icon, or undefined if not found
 */
export const getItemIcon = (itemId: string): ImageSourcePropType | undefined => {
  return ITEM_SOURCES[itemId]
}

/**
 * Get item by ID
 * @param itemId - The item ID
 * @returns IItem object or undefined
 */
export const getItem = (itemId: string): IItem | undefined => {
  return ITEMS.find((item) => item.id === itemId)
}

/**
 * Check if an item exists
 * @param itemId - The item ID
 * @returns boolean
 */
export const hasItem = (itemId: string): boolean => {
  return itemId in ITEM_SOURCES
}
`

  await writeFile(INDEX_FILE, indexContent)

  console.log('âœ… Done!\n')
  console.log(`   ğŸ“ ${processedItems.length} images in assets/items/`)
  console.log(`   ğŸ“„ index.ts generated\n`)
}

main().catch(console.error)
