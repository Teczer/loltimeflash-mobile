/**
 * Champion Splash Art Optimization Script
 * 
 * Copies all champion splash arts from the web app,
 * compresses them with Sharp, and generates the TypeScript index.
 * 
 * Run: bun run scripts/optimize-champions.ts
 */

import { readdir, mkdir, writeFile, copyFile, stat } from 'fs/promises';
import { existsSync } from 'fs';
import { join, basename } from 'path';

// Paths
const WEB_SPLASH_DIR = join(__dirname, '../../../apps/web/public/champions/splash');
const MOBILE_SPLASH_DIR = join(__dirname, '../assets/champions/splash');
const INDEX_FILE = join(__dirname, '../assets/champions/index.ts');

// Try to import sharp (optional)
let sharp: typeof import('sharp') | null = null;
try {
  sharp = require('sharp');
  console.log('‚úÖ Sharp available - will optimize images');
} catch {
  console.log('‚ö†Ô∏è Sharp not available - will copy images without optimization');
  console.log('   Install with: bun add -d sharp');
}

interface ChampionSkin {
  championName: string;
  skinIndex: number;
  fileName: string;
}

async function main() {
  console.log('\nüéÆ Champion Splash Art Optimization Script\n');

  // Ensure output directory exists
  if (!existsSync(MOBILE_SPLASH_DIR)) {
    await mkdir(MOBILE_SPLASH_DIR, { recursive: true });
  }

  // Read all splash files
  const files = await readdir(WEB_SPLASH_DIR);
  const webpFiles = files.filter(f => f.endsWith('.webp'));
  
  console.log(`üìÅ Found ${webpFiles.length} splash images\n`);

  // Parse and organize skins by champion
  const skins: ChampionSkin[] = [];
  
  for (const file of webpFiles) {
    // Parse filename: ChampionName_SkinIndex.webp
    const match = file.match(/^(.+)_(\d+)\.webp$/);
    if (match) {
      skins.push({
        championName: match[1],
        skinIndex: parseInt(match[2], 10),
        fileName: file,
      });
    }
  }

  // Group by champion
  const championMap = new Map<string, ChampionSkin[]>();
  for (const skin of skins) {
    const existing = championMap.get(skin.championName) || [];
    existing.push(skin);
    championMap.set(skin.championName, existing);
  }

  // Sort champions alphabetically and skins by index
  const sortedChampions = Array.from(championMap.keys()).sort();
  for (const champ of sortedChampions) {
    const skins = championMap.get(champ)!;
    skins.sort((a, b) => a.skinIndex - b.skinIndex);
  }

  console.log(`üë§ ${sortedChampions.length} champions\n`);

  // Process images
  let processed = 0;
  let totalOriginalSize = 0;
  let totalOptimizedSize = 0;

  for (const file of webpFiles) {
    const srcPath = join(WEB_SPLASH_DIR, file);
    const destPath = join(MOBILE_SPLASH_DIR, file);

    const originalStat = await stat(srcPath);
    totalOriginalSize += originalStat.size;

    if (sharp) {
      // Optimize with sharp
      await sharp(srcPath)
        .webp({ quality: 75, effort: 6 })
        .resize(1280, 720, { fit: 'inside', withoutEnlargement: true })
        .toFile(destPath);
    } else {
      // Just copy
      await copyFile(srcPath, destPath);
    }

    const destStat = await stat(destPath);
    totalOptimizedSize += destStat.size;

    processed++;
    if (processed % 100 === 0 || processed === webpFiles.length) {
      process.stdout.write(`\r‚è≥ Processing: ${processed}/${webpFiles.length}`);
    }
  }

  console.log('\n');

  // Size report
  const originalMB = (totalOriginalSize / 1024 / 1024).toFixed(1);
  const optimizedMB = (totalOptimizedSize / 1024 / 1024).toFixed(1);
  const savedPercent = ((1 - totalOptimizedSize / totalOriginalSize) * 100).toFixed(1);

  console.log(`üìä Size: ${originalMB}MB ‚Üí ${optimizedMB}MB (${savedPercent}% saved)\n`);

  // Generate TypeScript index
  console.log('üìù Generating TypeScript index...\n');

  let indexContent = `/**
 * Static champion splash art mappings
 * Auto-generated by scripts/optimize-champions.ts
 * 
 * Total: ${sortedChampions.length} champions, ${webpFiles.length} skins
 */
import { ImageSourcePropType } from 'react-native';

export interface ISkin {
  index: number;
  source: ImageSourcePropType;
}

export interface IChampion {
  name: string;
  skins: ISkin[];
}

`;

  // Generate requires for each champion
  for (const champName of sortedChampions) {
    const champSkins = championMap.get(champName)!;
    
    indexContent += `const ${champName}_SKINS: ISkin[] = [\n`;
    for (const skin of champSkins) {
      indexContent += `  { index: ${skin.skinIndex}, source: require('./splash/${skin.fileName}') },\n`;
    }
    indexContent += `];\n\n`;
  }

  // Generate CHAMPIONS array
  indexContent += `// All champions with their skins\nexport const CHAMPIONS: IChampion[] = [\n`;
  for (const champName of sortedChampions) {
    indexContent += `  { name: '${champName}', skins: ${champName}_SKINS },\n`;
  }
  indexContent += `];\n\n`;

  // Helper functions
  indexContent += `// Get champion by name
export const getChampion = (name: string): IChampion | undefined => {
  return CHAMPIONS.find((c) => c.name === name);
};

// Get base skin (index 0) for a champion
export const getBaseSkin = (name: string): ImageSourcePropType | null => {
  const champion = getChampion(name);
  if (!champion || champion.skins.length === 0) return null;
  return champion.skins[0].source;
};

// Default background
export const DEFAULT_CHAMPION = 'Aurora';
export const DEFAULT_SPLASH = getBaseSkin('Aurora')!;
`;

  await writeFile(INDEX_FILE, indexContent);

  console.log('‚úÖ Done!\n');
  console.log(`   üìÅ ${webpFiles.length} images in assets/champions/splash/`);
  console.log(`   üìÑ index.ts generated with ${sortedChampions.length} champions\n`);
}

main().catch(console.error);
